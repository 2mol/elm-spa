[{"name":"Application","comment":" Let's build some single page applications!\n\n\n# Terrifying types ahead 😬\n\nThe `elm-spa` package makes your _functions look nice_,\nbut holy cow do those type annotations get intimidating!\n\n\n## But why tho? 🤔\n\nSo much of the types are defined in _your app_, and this package needs\nto use generic types to understand them correctly.\n\nIn practice, this actually leads to your code looking like this\n\n    init route_ =\n        case route_ of\n            Route.Foo route ->\n                foo.init route\n\n            Route.Bar route ->\n                bar.init route\n\n            Route.Baz route ->\n                baz.init route\n\n            _ ->\n                Page.keep model_\n\n( Instead of a crazy nested torture chamber of doom )\n\n\n## Anyway, enough excuses from me! 🤐\n\nCheck out the examples below to decide for yourself!\n\n\n# Program\n\nAt a high-level, `elm-spa` replaces [Browser.application](https://package.elm-lang.org/packages/elm/browser/latest/Browser#application)\nso you don't have to deal with `Url` or `Nav.Key`!\n\nYou can create a `Program` with `Application.create`:\n\n    module Main exposing (main)\n\n    import Application\n    import Generated.Pages as Pages\n    import Generated.Route as Route\n    import Global\n\n    main =\n        Application.create\n            { options = Application.defaultOptions\n            , routing =\n                { routes = Route.routes\n                , toPath = Route.toPath\n                , notFound = Route.NotFound ()\n                }\n            , global =\n                { init = Global.init\n                , update = Global.update\n                , subscriptions = Global.subscriptions\n                }\n            , page = Pages.page\n            }\n\n\n\n@docs Program, create\n\n\n# Using elm-ui?\n\nIf you're a fan of [mdgriffith/elm-ui](https://package.elm-lang.org/packages/mdgriffith/elm-ui/latest/),\nit's important to support using `Element msg` instead of `Html msg` for your pages and components.\n\nLet `Application.create` know about this by passing in your own `Options` like these:\n\n    import Element\n    -- other imports\n\n    Application.create\n        { options =\n            { toHtml = Element.layout []\n            , map = Element.map\n            }\n        , -- ... the rest of your app\n        }\n\n@docs Options, defaultOptions\n\n","unions":[],"aliases":[{"name":"Options","comment":" Useful for using packages like [elm-ui](https://package.elm-lang.org/packages/mdgriffith/elm-ui/latest/)\n\n    import Element\n\n    options =\n        { toHtml = Element.layout []\n        , map = Element.map\n        }\n\nThis tells your app how to convert into `Html msg` when it's time to render to the page.\n\n","args":["layoutMsg","globalMsg","htmlLayoutMsg","htmlMsg"],"type":"{ toHtml : htmlMsg -> Html.Html (Application.Msg globalMsg layoutMsg), map : (layoutMsg -> Application.Msg globalMsg layoutMsg) -> htmlLayoutMsg -> htmlMsg }"},{"name":"Program","comment":" An alias for `Platform.Program` to make annotations a little more clear.\n","args":["flags","globalModel","globalMsg","layoutModel","layoutMsg"],"type":"Platform.Program flags (Application.Model flags globalModel layoutModel) (Application.Msg globalMsg layoutMsg)"}],"values":[{"name":"create","comment":" Creates a new `Program` given some one-time configuration:\n\n  - `options` - How do we convert the view to `Html msg`?\n  - `routing` - What are the app's routes?\n  - `global` - How do we maintain the global app state\n  - `page` - What pages do we have available?\n\n","type":"{ options : Application.Options layoutMsg globalMsg htmlLayoutMsg htmlMsg, routing : { routes : Application.Routes route, toPath : route -> String.String, notFound : route }, global : { init : { navigate : route -> Platform.Cmd.Cmd (Application.Msg globalMsg layoutMsg) } -> flags -> ( globalModel, Platform.Cmd.Cmd globalMsg, Platform.Cmd.Cmd (Application.Msg globalMsg layoutMsg) ), update : { navigate : route -> Platform.Cmd.Cmd (Application.Msg globalMsg layoutMsg) } -> globalMsg -> globalModel -> ( globalModel, Platform.Cmd.Cmd globalMsg, Platform.Cmd.Cmd (Application.Msg globalMsg layoutMsg) ), subscriptions : globalModel -> Platform.Sub.Sub globalMsg }, page : Internals.Page.Page route layoutModel layoutMsg htmlLayoutMsg layoutModel layoutMsg htmlLayoutMsg globalModel globalMsg (Application.Msg globalMsg layoutMsg) htmlMsg } -> Application.Program flags globalModel globalMsg layoutModel layoutMsg"},{"name":"defaultOptions","comment":" Just using `elm/html`? Pass this in when calling `Application.create`\n\n( It will work if your view returns the standard `Html msg` )\n\n","type":"Application.Options layoutMsg globalMsg (Html.Html layoutMsg) (Html.Html (Application.Msg globalMsg layoutMsg))"}],"binops":[]},{"name":"Application.Page","comment":" Each page can be as simple or complex as you need:\n\n1.  [Static](#static) - for rendering a simple view\n\n2.  [Sandbox](#sandbox) - for maintaining state, without any side-effects\n\n3.  [Element](#element) - for maintaining state, **with** side-effects\n\n4.  [Component](#component) - for a full-blown page, that can view and update global state\n\n\n## Static\n\nFor rendering a simple view.\n\n    page =\n        Page.static\n            { title = title\n            , view = view\n            }\n\n@docs Static, static\n\n\n## Sandbox\n\nFor maintaining state, without any side-effects.\n\n    page =\n        Page.sandbox\n            { title = title\n            , init = init\n            , update = update\n            , view = view\n            }\n\n@docs Sandbox, sandbox\n\n\n## Element\n\nFor maintaining state, **with** side-effects.\n\n    page =\n        Page.element\n            { title = title\n            , init = init\n            , update = update\n            , view = view\n            , subscriptions = subscriptions\n            }\n\n@docs Element, element\n\n\n## Component\n\nFor a full-blown page, that can view and update global state.\n\n    page =\n        Page.component\n            { title = title\n            , init = init\n            , update = update\n            , view = view\n            , subscriptions = subscriptions\n            }\n\n@docs Component, component\n\n\n# Composing pages together\n\nThe rest of this module contains types and functions that\ncan be generated with the [cli companion tool](https://github.com/ryannhg/elm-spa/tree/master/cli)\n\nIf you're typing this stuff manually, you might need to know what\nthese are for!\n\n\n## Layout\n\nA page that is comprimised of smaller pages, that is\nable to share a common layout (maybe a something like a sidebar!)\n\n    page =\n        Page.layout\n            { map = Html.map\n            , layout = Layout.view\n            , pages =\n                { init = init\n                , update = update\n                , bundle = bundle\n                }\n            }\n\n@docs Layout, layout\n\n\n## Recipes and helpers\n\nImplementing the `init`, `update` and `bundle` functions is much easier\nwhen you turn a `Page` type into `Recipe`.\n\nA `Recipe` contains a record waiting for page specific data.\n\n  - `init`: just needs a `route`\n\n  - `upgrade` : just needs a `msg` and `model`\n\n  - `bundle` (`view`/`subscriptions`) : just needs a `model`\n\n(**Fun fact:** We're can determine `view` and `subscriptions` in the same `case` expression,\nbecause they both only depend on the current `model`. That's why `bundle` exists!)\n\n@docs recipe, keep\n\n","unions":[],"aliases":[{"name":"Component","comment":"\n\n    title : Global.Model -> Model -> String\n\n    init : Global.Model -> Route -> ( Model, Cmd Msg, Cmd Global.Msg )\n\n    update : Global.Model -> Msg -> Model -> ( Model, Cmd Msg, Cmd Global.Msg )\n\n    view : Global.Model -> Model -> Html Msg\n\n    subscriptions : Global.Model -> Model -> Sub Msg\n\n","args":["pageRoute","pageModel","pageMsg","globalModel","globalMsg","htmlPageMsg"],"type":"{ title : globalModel -> pageModel -> String.String, init : globalModel -> pageRoute -> ( pageModel, Platform.Cmd.Cmd pageMsg, Platform.Cmd.Cmd globalMsg ), update : globalModel -> pageMsg -> pageModel -> ( pageModel, Platform.Cmd.Cmd pageMsg, Platform.Cmd.Cmd globalMsg ), view : globalModel -> pageModel -> htmlPageMsg, subscriptions : globalModel -> pageModel -> Platform.Sub.Sub pageMsg }"},{"name":"Element","comment":"\n\n    title : Model -> String\n\n    init : Route -> ( Model, Cmd Msg )\n\n    update : Msg -> Model -> ( Model, Cmd Msg )\n\n    view : Model -> Html Msg\n\n    subscriptions : Model -> Sub Msg\n\n","args":["pageRoute","pageModel","pageMsg","htmlPageMsg"],"type":"{ title : pageModel -> String.String, init : pageRoute -> ( pageModel, Platform.Cmd.Cmd pageMsg ), update : pageMsg -> pageModel -> ( pageModel, Platform.Cmd.Cmd pageMsg ), view : pageModel -> htmlPageMsg, subscriptions : pageModel -> Platform.Sub.Sub pageMsg }"},{"name":"Layout","comment":" These are used by top-level files like `src/Generated/Pages.elm`\nto compose together pages and layouts.\n\nWe'll get a better understanding of `init`, `update`, and `bundle` below!\n\n","args":["pageRoute","pageModel","pageMsg","globalModel","globalMsg","msg","htmlPageMsg","htmlMsg"],"type":"{ map : (pageMsg -> msg) -> htmlPageMsg -> htmlMsg, view : { page : htmlMsg, global : globalModel } -> htmlMsg, pages : Internals.Page.Recipe pageRoute pageModel pageMsg pageModel pageMsg htmlPageMsg globalModel globalMsg msg htmlMsg }"},{"name":"Sandbox","comment":"\n\n    title : Model -> String\n\n    init : Route -> Model\n\n    update : Msg -> Model -> Model\n\n    view : Model -> Html Msg\n\n","args":["pageRoute","pageModel","pageMsg","htmlPageMsg"],"type":"{ title : pageModel -> String.String, init : pageRoute -> pageModel, update : pageMsg -> pageModel -> pageModel, view : pageModel -> htmlPageMsg }"},{"name":"Static","comment":"\n\n    title : String\n\n    view : Html msg\n\n","args":["htmlPageMsg"],"type":"{ title : String.String, view : htmlPageMsg }"}],"values":[{"name":"component","comment":" Create an `component` page from a record. [Here's an example](https://github.com/ryannhg/elm-spa/examples/html/src/Pages/SignIn.elm)\n\n","type":"Application.Page.Component pageRoute pageModel pageMsg globalModel globalMsg htmlPageMsg -> Application.Page.Page pageRoute pageModel pageMsg htmlPageMsg layoutModel layoutMsg htmlLayoutMsg globalModel globalMsg msg htmlMsg"},{"name":"element","comment":" Create an `element` page from a record. [Here's an example](https://github.com/ryannhg/elm-spa/examples/html/src/Pages/Random.elm)\n","type":"Application.Page.Element pageRoute pageModel pageMsg htmlPageMsg -> Application.Page.Page pageRoute pageModel pageMsg htmlPageMsg layoutModel layoutMsg htmlLayoutMsg globalModel globalMsg msg htmlMsg"},{"name":"keep","comment":" In the event that our `case` expression in `update` receives a `msg` that doesn't\nmatch it's `model`, we use this function to keep the model as-is.\n\n    update msg_ model_ =\n        case ( msg_, model_ ) of\n            ( FooMsg msg, FooModel model ) ->\n                foo.update msg model\n\n            ( BarMsg msg, BarModel model ) ->\n                bar.update msg model\n\n            ( BazMsg msg, BazModel model ) ->\n                baz.update msg model\n\n            _ ->\n                Page.keep model_\n\n","type":"layoutModel -> Internals.Page.Update layoutModel layoutMsg globalModel globalMsg"},{"name":"layout","comment":"\n\n    Page.layout\n        { map = Html.map\n        , layout = Layout.view\n        , pages =\n            { init = init\n            , update = update\n            , bundle = bundle\n            }\n        }\n\n","type":"Application.Page.Layout pageRoute pageModel pageMsg globalModel globalMsg msg htmlPageMsg htmlMsg -> Application.Page.Page pageRoute pageModel pageMsg htmlPageMsg layoutModel layoutMsg htmlLayoutMsg globalModel globalMsg msg htmlMsg"},{"name":"recipe","comment":" Turns a page and some upgrade information into a recipe,\nfor use in a layout's `init`, `update, and`bundle\\` functions!\n\n    Page.recipe Homepage.page\n        { toModel = HomepageModel\n        , toMsg = HomepageMsg\n        , map = Element.map -- ( if using elm-ui )\n        }\n\n","type":"Application.Page.Page pageRoute pageModel pageMsg htmlPageMsg layoutModel layoutMsg htmlLayoutMsg globalModel globalMsg msg htmlMsg -> { toModel : pageModel -> layoutModel, toMsg : pageMsg -> layoutMsg, map : (pageMsg -> layoutMsg) -> htmlPageMsg -> htmlLayoutMsg } -> Internals.Page.Recipe pageRoute pageModel pageMsg layoutModel layoutMsg htmlLayoutMsg globalModel globalMsg msg htmlMsg"},{"name":"sandbox","comment":" Create an `sandbox` page from a record. [Here's an example](https://github.com/ryannhg/elm-spa/examples/html/src/Pages/Counter.elm)\n","type":"Application.Page.Sandbox pageRoute pageModel pageMsg htmlPageMsg -> Application.Page.Page pageRoute pageModel pageMsg htmlPageMsg layoutModel layoutMsg htmlLayoutMsg globalModel globalMsg msg htmlMsg"},{"name":"static","comment":" Create an `static` page from a record. [Here's an example](https://github.com/ryannhg/elm-spa/examples/html/src/Pages/Index.elm)\n","type":"Application.Page.Static htmlPageMsg -> Application.Page.Page pageRoute () Basics.Never htmlPageMsg layoutModel layoutMsg htmlLayoutMsg globalModel globalMsg msg htmlMsg"}],"binops":[]},{"name":"Application.Route","comment":"\n\n\n# Routing\n\nThe [cli tool](https://github.com/ryannhg/elm-spa/tree/master/cli) is able to generate routes based on the folder\nstructure and files in the `src/Pages` folder.\n\nIf you're choosing to type out the routes manually, these are just\nconvenience functions for creating `Url.Parser` types for your application.\n\n@docs Route\n\n@docs index\n\n@docs path\n\n@docs slug\n\n@docs folder\n\n","unions":[],"aliases":[{"name":"Route","comment":" Literally just a Url.Parser under the hood.\n","args":["route"],"type":"Url.Parser.Parser (route -> route) route"}],"values":[{"name":"folder","comment":" A route for nested routes, generated by a folder.\n\n    Route.folder \"settings\" Settings Settings.routes\n\n","type":"String.String -> (a -> route) -> List.List (Application.Route.Route a) -> Application.Route.Route route"},{"name":"index","comment":" A top level route.\nUsually generated by an `Index.elm` file.\n\n    Route.index Index\n\n","type":"(() -> route) -> Application.Route.Route route"},{"name":"path","comment":" A route for a path like. These are generated by other file names.\n\n    Route.path \"about-us\" AboutUs\n\n","type":"String.String -> (() -> route) -> Application.Route.Route route"},{"name":"slug","comment":" A dynamic route, that passes the `String` value.\nUsually generated by an `Slug.elm` file.\n\n    Route.slug Slug\n\n","type":"(String.String -> route) -> Application.Route.Route route"}],"binops":[]}]