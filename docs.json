[{"name":"Application","comment":"\n\n\n## Let's build some single page applications!\n\n`Application.create` replaces [Browser.application](https://package.elm-lang.org/packages/elm/browser/latest/Browser#application)\nas the entrypoint to your app.\n\n    module Main exposing (main)\n\n    import Application\n    import Generated.Pages as Pages\n    import Generated.Route as Route\n    import Global\n\n    main =\n        Application.create\n            { ui = Application.usingHtml\n            , routing =\n                { routes = Route.routes\n                , toPath = Route.toPath\n                , notFound = Route.NotFound ()\n                }\n            , global =\n                { init = Global.init\n                , update = Global.update\n                , subscriptions = Global.subscriptions\n                }\n            , page = Pages.page\n            }\n\n@docs Program, create\n\n\n# Supports more than elm/html\n\nIf you're a fan of [mdgriffith/elm-ui](https://package.elm-lang.org/packages/mdgriffith/elm-ui/latest/),\nit's important to support using `Element msg` instead of `Html msg` for your pages and components.\n\nLet `Application.create` know about this by passing in your own `Options` like these:\n\n    import Element\n    -- other imports\n\n    Application.create\n        { ui =\n            { toHtml = Element.layout []\n            , map = Element.map\n            }\n        , -- ... the rest of your app\n        }\n\n@docs usingHtml\n\n","unions":[],"aliases":[{"name":"Program","comment":" An alias for `Platform.Program` to make annotations a little more clear.\n","args":["flags","globalModel","globalMsg","layoutModel","layoutMsg"],"type":"Platform.Program flags (Application.Model flags globalModel layoutModel) (Application.Msg globalMsg layoutMsg)"}],"values":[{"name":"create","comment":" Creates a new `Program` given some one-time configuration:\n\n  - `ui` - How do we convert the view to `Html msg`?\n  - `routing` - What are the app's routes?\n  - `global` - How do we manage shared state between pages?\n  - `page` - What pages do we have available?\n\n","type":"{ ui : { toHtml : uiMsg -> Html.Html (Application.Msg globalMsg layoutMsg), map : (layoutMsg -> Application.Msg globalMsg layoutMsg) -> uiLayoutMsg -> uiMsg }, routing : { routes : List.List (Application.Route.Route route), toPath : route -> String.String, notFound : route }, global : { init : { navigate : route -> Platform.Cmd.Cmd (Application.Msg globalMsg layoutMsg) } -> flags -> ( globalModel, Platform.Cmd.Cmd globalMsg, Platform.Cmd.Cmd (Application.Msg globalMsg layoutMsg) ), update : { navigate : route -> Platform.Cmd.Cmd (Application.Msg globalMsg layoutMsg) } -> globalMsg -> globalModel -> ( globalModel, Platform.Cmd.Cmd globalMsg, Platform.Cmd.Cmd (Application.Msg globalMsg layoutMsg) ), subscriptions : globalModel -> Platform.Sub.Sub globalMsg }, page : Internals.Page.Page route layoutModel layoutMsg uiLayoutMsg layoutModel layoutMsg uiLayoutMsg globalModel globalMsg (Application.Msg globalMsg layoutMsg) uiMsg } -> Application.Program flags globalModel globalMsg layoutModel layoutMsg"},{"name":"usingHtml","comment":" Pass this in when calling `Application.create`\n\n( It will work if your view returns the standard `Html msg` )\n\n","type":"{ map : (layoutMsg -> Application.Msg globalMsg layoutMsg) -> Html.Html layoutMsg -> Html.Html (Application.Msg globalMsg layoutMsg), toHtml : uiMsg -> uiMsg }"}],"binops":[]},{"name":"Application.Page","comment":" Each page can be as simple or complex as you need:\n\n1.  [Static](#static) - for rendering a simple view\n\n2.  [Sandbox](#sandbox) - for maintaining state, without any side-effects\n\n3.  [Element](#element) - for maintaining state, **with** side-effects\n\n4.  [Component](#component) - for a full-blown page, that can view and update global state\n\n\n## Static\n\nFor rendering a simple view.\n\n    page =\n        Page.static\n            { title = title\n            , view = view\n            }\n\n@docs static\n\n\n## Sandbox\n\nFor maintaining state, without any side-effects.\n\n    page =\n        Page.sandbox\n            { title = title\n            , init = init\n            , update = update\n            , view = view\n            }\n\n@docs sandbox\n\n\n## Element\n\nFor maintaining state, **with** side-effects.\n\n    page =\n        Page.element\n            { title = title\n            , init = init\n            , update = update\n            , view = view\n            , subscriptions = subscriptions\n            }\n\n@docs element\n\n\n## Component\n\nFor a full-blown page, that can view and update global state.\n\n    page =\n        Page.component\n            { title = title\n            , init = init\n            , update = update\n            , view = view\n            , subscriptions = subscriptions\n            }\n\n@docs component\n\n\n# Composing pages together\n\nThe rest of this module contains types and functions that\ncan be generated with the [cli companion tool](https://github.com/ryannhg/elm-spa/tree/master/cli)\n\nIf you're typing this stuff manually, you might need to know what\nthese are for!\n\n\n## Layout\n\nA page that is comprimised of smaller pages, that is\nable to share a common layout (maybe a something like a sidebar!)\n\n    page =\n        Page.layout\n            { map = Html.map\n            , layout = Layout.view\n            , pages =\n                { init = init\n                , update = update\n                , bundle = bundle\n                }\n            }\n\n@docs layout\n\n\n## Recipe\n\nImplementing the `init`, `update` and `bundle` functions is much easier\nwhen you turn a `Page` type into `Recipe`.\n\nA `Recipe` contains a record waiting for page specific data.\n\n  - `init`: just needs a `route`\n\n  - `upgrade` : just needs a `msg` and `model`\n\n  - `bundle` (`view`/`subscriptions`) : just needs a `model`\n\n\n### What's a \"bundle\"?\n\nWe can \"bundle\" the `view` and `subscriptions` functions together,\nbecause they both only depend on the current `model`. That's why this\nAPI exposes `bundle` instead of making you type this:\n\n    -- BEFORE\n    view model =\n        case model_ of\n            FooModel model ->\n                foo.view model\n\n            BarModel model ->\n                bar.view model\n\n            BazModel model ->\n                baz.view model\n\n    subscriptions model =\n        case model_ of\n            FooModel model ->\n                foo.subscriptions model\n\n            BarModel model ->\n                bar.subscriptions model\n\n            BazModel model ->\n                baz.subscriptions model\n\n    -- AFTER\n    bundle model =\n        case model_ of\n            FooModel model ->\n                foo.bundle model\n\n            BarModel model ->\n                bar.bundle model\n\n            BazModel model ->\n                baz.bundle model\n\n(Woohoo, less case expressions to type out!)\n\n@docs recipe\n\n\n## Update helper\n\n@docs keep\n\n","unions":[],"aliases":[],"values":[{"name":"component","comment":" Create an `component` page from a record. [Here's an example](https://github.com/ryannhg/elm-spa/examples/html/src/Pages/SignIn.elm)\n","type":"{ title : globalModel -> pageModel -> String.String, init : globalModel -> pageRoute -> ( pageModel, Platform.Cmd.Cmd pageMsg, Platform.Cmd.Cmd globalMsg ), update : globalModel -> pageMsg -> pageModel -> ( pageModel, Platform.Cmd.Cmd pageMsg, Platform.Cmd.Cmd globalMsg ), view : globalModel -> pageModel -> uiPageMsg, subscriptions : globalModel -> pageModel -> Platform.Sub.Sub pageMsg } -> Application.Page.Page pageRoute pageModel pageMsg uiPageMsg layoutModel layoutMsg uiLayoutMsg globalModel globalMsg msg uiMsg"},{"name":"element","comment":" Create an `element` page from a record. [Here's an example](https://github.com/ryannhg/elm-spa/examples/html/src/Pages/Random.elm)\n","type":"{ title : pageModel -> String.String, init : pageRoute -> ( pageModel, Platform.Cmd.Cmd pageMsg ), update : pageMsg -> pageModel -> ( pageModel, Platform.Cmd.Cmd pageMsg ), view : pageModel -> uiPageMsg, subscriptions : pageModel -> Platform.Sub.Sub pageMsg } -> Application.Page.Page pageRoute pageModel pageMsg uiPageMsg layoutModel layoutMsg uiLayoutMsg globalModel globalMsg msg uiMsg"},{"name":"keep","comment":" In the event that our `case` expression in `update` receives a `msg` that doesn't\nmatch it's `model`, we use this function to keep the model as-is.\n\n    update msg_ model_ =\n        case ( msg_, model_ ) of\n            ( FooMsg msg, FooModel model ) ->\n                foo.update msg model\n\n            ( BarMsg msg, BarModel model ) ->\n                bar.update msg model\n\n            ( BazMsg msg, BazModel model ) ->\n                baz.update msg model\n\n            _ ->\n                Page.keep model_\n\n","type":"layoutModel -> Internals.Page.Update layoutModel layoutMsg globalModel globalMsg"},{"name":"layout","comment":" These are used by top-level files like `src/Generated/Pages.elm`\nto compose together pages and layouts.\n\nWe'll get a better understanding of `init`, `update`, and `bundle` below!\n\n    Page.layout\n        { map = Html.map\n        , layout = Layout.view\n        , pages =\n            { init = init\n            , update = update\n            , bundle = bundle\n            }\n        }\n\n","type":"{ map : (pageMsg -> msg) -> uiPageMsg -> uiMsg, view : { page : uiMsg, global : globalModel } -> uiMsg, pages : Internals.Page.Recipe pageRoute pageModel pageMsg pageModel pageMsg uiPageMsg globalModel globalMsg msg uiMsg } -> Application.Page.Page pageRoute pageModel pageMsg uiPageMsg layoutModel layoutMsg uiLayoutMsg globalModel globalMsg msg uiMsg"},{"name":"recipe","comment":" Turns a page and some upgrade information into a recipe,\nfor use in a layout's `init`, `update`, and `bundle` functions!\n\n    Page.recipe Homepage.page\n        { toModel = HomepageModel\n        , toMsg = HomepageMsg\n        , map = Element.map -- ( if using elm-ui )\n        }\n\n","type":"Application.Page.Page pageRoute pageModel pageMsg uiPageMsg layoutModel layoutMsg uiLayoutMsg globalModel globalMsg msg uiMsg -> { toModel : pageModel -> layoutModel, toMsg : pageMsg -> layoutMsg, map : (pageMsg -> layoutMsg) -> uiPageMsg -> uiLayoutMsg } -> Internals.Page.Recipe pageRoute pageModel pageMsg layoutModel layoutMsg uiLayoutMsg globalModel globalMsg msg uiMsg"},{"name":"sandbox","comment":" Create an `sandbox` page from a record. [Here's an example](https://github.com/ryannhg/elm-spa/examples/html/src/Pages/Counter.elm)\n","type":"{ title : pageModel -> String.String, init : pageRoute -> pageModel, update : pageMsg -> pageModel -> pageModel, view : pageModel -> uiPageMsg } -> Application.Page.Page pageRoute pageModel pageMsg uiPageMsg layoutModel layoutMsg uiLayoutMsg globalModel globalMsg msg uiMsg"},{"name":"static","comment":" Create an `static` page from a record. [Here's an example](https://github.com/ryannhg/elm-spa/examples/html/src/Pages/Index.elm)\n","type":"{ title : String.String, view : uiPageMsg } -> Application.Page.Page pageRoute () Basics.Never uiPageMsg layoutModel layoutMsg uiLayoutMsg globalModel globalMsg msg uiMsg"}],"binops":[]},{"name":"Application.Route","comment":"\n\n\n# Routing\n\nThe [cli tool](https://github.com/ryannhg/elm-spa/tree/master/cli) is able to generate routes based on the folder\nstructure and files in the `src/Pages` folder.\n\nIf you're choosing to type out the routes manually, these are just\nconvenience functions for creating `Url.Parser` types for your application.\n\n@docs Route\n\n@docs index\n\n@docs path\n\n@docs slug\n\n@docs folder\n\n","unions":[],"aliases":[{"name":"Route","comment":" Literally just a Url.Parser under the hood.\n","args":["route"],"type":"Url.Parser.Parser (route -> route) route"}],"values":[{"name":"folder","comment":" A route for nested routes, generated by a folder.\n\n    Route.folder \"settings\" Settings Settings.routes\n\n","type":"String.String -> (a -> route) -> List.List (Application.Route.Route a) -> Application.Route.Route route"},{"name":"index","comment":" A top level route.\nUsually generated by an `Index.elm` file.\n\n    Route.index Index\n\n","type":"(() -> route) -> Application.Route.Route route"},{"name":"path","comment":" A route for a path like. These are generated by other file names.\n\n    Route.path \"about-us\" AboutUs\n\n","type":"String.String -> (() -> route) -> Application.Route.Route route"},{"name":"slug","comment":" A dynamic route, that passes the `String` value.\nUsually generated by an `Slug.elm` file.\n\n    Route.slug Slug\n\n","type":"(String.String -> route) -> Application.Route.Route route"}],"binops":[]}]